# 폰 노이만 아키텍처

## 개요

- 프로그램 내장 방식이라고도 불리는 컴퓨터 구조
- 저장된 프로그램 개념 도입
    - 프로그램을 구성하는 명령어들을 실행 순서대로 배열하고
    - 조건분기(조건에 따라 메모리의 특정 위치에 있는 코드를 실행)를 무제한으로 허용
- CPU, 메모리, 프로그램의 세가지 구성요소로 이루어짐

  

## 장점

1. 컴퓨터에 다른 작업을 시키고자 할때 하드웨어 재배치 없이, 소프트웨어만 교체하므로 범용성 향상
2. 소프트웨어의 복제 용이성으로 같은 작업을 다른 환경에서도 동일하게 수행 가능

  

## 단점

1. 폰노이만 병목현상 - CPU와 메모리의 속도 차이로 인한 성능 저하 문제

  

  

  

# Instruction Set Architecture (ISA)

> [!important]
> 
> - CPU가 인식, 해석, 실행할 수 있는 명령어들의 모음
> - 소프트웨어와 하드웨어 사이의 인터페이스
> - ISA를 물리적으로 구현하는 방법을 마이크로 아키텍처라고 한다

## CISC (Complex Instruction Set Computer)

- 복잡하고 많은 종류의 명령어와 주소 지정 모드를 사용한다.
- 명령어의 형태와 크기가 다양해서 명령어의 길이가 가변적이다.
- 100개 ~ 250개 정도의 많은 명령어를 가지고 있어 설계가 어렵다.

  

> 장점

1. 명령어가 많아 호환성이 좋음
2. 강력한 명령어 몇개만 사용해서 수행 가능 → 메모리 공간 절약
3. 가변길이 명령어 덕분에 마이크로 코드 구현이 비교적 편함

  

> 단점

1. 명령어가 복잡하고 다양한 기능을 제공하여 실행시간이 일정하지 않음
    - 규격화되지 않아 파이프라인이 효율적으로 처리 불가
    - 속도가 느림, 전력소모가 많음
2. 구조가 복잡해서 설계 어려움
3. 복잡한 명령어는 사용 빈도가 낮음
4. 메모리 성능이 좋아지면서 장점이 퇴색됨

> [!important] **파이프라이닝 (Pipelining)**
> 
> - 인출과 실행 단계가 겹치도록 프로세서를 설계해서 명령어 여러 개가 다양한 단계에 걸쳐 진행되도록 만들 수 있다.
> - 명령어 한개가 완료되는 데는 여전히 같은 시간이 걸리지만, 여러 개의 명령어를 동시에 처리하므로 전체적인 처리 속도는 빨라진다.

## **RISC (Reduced Instruction Set Computer)**

- 간단하고 적은 종류의 명령어와 주소 지정 모드를 사용한다.
- 고정 길이 명령어 형식이다.
- CISC에 비해 명령어 수가 적다.

  

> 장점

1. 메모리 접근 명령어가 load / store 두개로 단순화됨
    - 레지스터를 적극 활용하여 하드웨어 구조가 단순해지고 레이턴시 낮아짐
    - 명령어 낭비 감소
2. 명령어 실행시간이 고정되어 파이프라이닝에 최적화, 해석 속도가 빠름
3. 전력 소모가 적음

  

> 단점

1. 명령어가 하드웨어적이므로 호환성이 낮음
2. 많은 레지스터 필요
3. 명령어 길이가 제약되어 명령의 점프 불가

  

# 마이크로아키텍처

> [!important] **마이크로아키텍처란, 명령어 집합(ISA)을 어떻게 하드웨어적으로 구현할지를 구체화한 설계 구조**입니다.

## 슈퍼스칼라(Superscalar)

- 현대 CPU에서 사용되는 고급 설계 방식
- **단일 프로세서 내에서 여러 명령어를 동시에 실행**할 수 있도록 설계된 구조
- 명령어 수준 병렬성(Instruction-Level Parallelism, ILP)을 활용하여 CPU의 처리 성능을 극대화합니다.

## 슈퍼스칼라의 주요 특징

1. **다중 실행 유닛(Multiple Execution Units)**:
    - 슈퍼스칼라 CPU는 여러 실행 유닛(ALU, FPU 등)을 포함하여 다양한 명령어를 병렬로 처리합니다
    - 예를 들어, 하나의 실행 유닛이 산술 연산을 수행하는 동안 다른 실행 유닛은 메모리 접근 작업을 처리할 수 있습니다.
2. **명령어 동시 실행**:
    - 단일 클럭 사이클 동안 여러 명령어를 동시에 실행합니다.
    - 이를 위해 CPU는 명령어의 **독립성**을 분석하여 병렬로 실행 가능한 명령어를 식별하고 분배합니다.
3. **명령어 스케줄링 및 디스패치**:
    - CPU 내부의 **명령어 스케줄러**가 명령어 스트림을 분석하여 병렬로 실행 가능한 명령어를 각 실행 유닛에 동적으로 할당합니다.
4. **파이프라인과의 차이점**:
    - 파이프라이닝은 단일 명령어를 여러 단계로 나눠 처리하는 방식인 반면, 슈퍼스칼라는 **여러 명령어를 동시에 처리**하는 데 초점을 둡니다.
5. **효율적인 자원 활용**:
    - 슈퍼스칼라 아키텍처는 독립적인 명령어만 병렬로 실행하므로, 데이터 의존성이나 제어 흐름 충돌이 없는 경우에 성능이 극대화됩니다.

---

## 슈퍼스칼라의 장점

- **향상된 처리 성능**: 한 클럭 사이클에 여러 명령어를 처리하여 CPU의 총 처리량(Throughput)을 증가시킵니다.
- **병렬성 활용**: 명령어 수준 병렬성을 최대한 활용하여 작업 속도를 높입니다.
- **다양한 작업 지원**: 복잡한 계산, 멀티미디어 처리, 인공지능 연산 등 고성능 작업에 적합합니다.

---

## 슈퍼스칼라의 한계

1. **데이터 의존성 문제**:
    - 명령어 간 데이터 의존성이 존재하면 병렬 처리가 제한될 수 있습니다.
    - 이를 해결하기 위해 슈퍼스칼라 CPU는 동적 데이터 의존성 분석 및 분기 예측 기술을 사용합니다.
2. **하드웨어 복잡성 증가**:
    - 여러 실행 유닛과 스케줄링 로직을 포함하기 때문에 설계와 구현이 복잡하고 비용이 증가합니다.
3. **효율성 저하 가능성**:
    - 독립적인 명령어가 충분히 많지 않으면 실행 유닛이 비활성 상태로 남아 자원이 낭비될 수 있습니다.